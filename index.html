<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>XAI Robot 2026: Final Stable</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0b0d11; color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { display: flex; gap: 30px; margin-top: 15px; justify-content: center; flex-wrap: wrap; }
        canvas { border: 2px solid #2c3e50; background: #000; border-radius: 4px; }
        .debug-panel { display: flex; flex-direction: column; gap: 15px; width: 340px; }
        .stat { background: #161b22; padding: 15px; border-radius: 8px; border-left: 5px solid #00e676; line-height: 1.6; }
        .heatmap-container { display: flex; gap: 15px; margin-top: 10px; }
        .heatmap-box { text-align: center; font-size: 11px; background: #161b22; padding: 10px; border-radius: 6px; }
        h2 { color: #00e676; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

    <h2>XAI Robot: Pathfinding Master</h2>
    
    <div class="container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div class="debug-panel">
            <div class="stat">
                <b>Статус:</b> <span id="status">Запуск...</span><br>
                <b>Шаг:</b> <span id="stepCountDisplay">0</span> | <b>Награда:</b> <span id="lastReward">0</span><br>
                <b>Координаты:</b> <span id="coords">0, 0</span>
            </div>
            <div class="heatmap-container">
                <div class="heatmap-box">
                    <canvas id="mapForward" width="100" height="100"></canvas>
                    <div style="margin-top:5px; color:#00e676">Q: Вперед</div>
                </div>
                <div class="heatmap-box">
                    <canvas id="mapTurn" width="100" height="100"></canvas>
                    <div style="margin-top:5px; color:#ffeb3b">Q: Поворот</div>
                </div>
            </div>
            <p style="font-size: 0.8em; color: #8b949e;">Если робот крутится, подождите 10-20 шагов: штраф истории (карта справа) потемнеет и заставит его сдвинуться.</p>
        </div>
    </div>

<script>
class TensorEngine {
    constructor(size) {
        this.size = size;
        this.actions = 2;
        this.gamma = 0.98; // Увеличена значимость будущего
        this.lr = 0.5;    // Ускорена скорость обучения

        this.weights = tf.variable(tf.randomUniform([size, size, 2, this.actions], 0.01, 0.1));
        
        this.hDepth = 100; // Углублена память
        this.historyBuffer = tf.variable(tf.zeros([this.hDepth, this.actions]));
        this.historyWeights = tf.variable(tf.fill([this.hDepth, this.actions], -2.5)); // Жесткое подавление циклов
    }

    predict(y, x, hasLoad) {
        return tf.tidy(() => {
            const spatialQ = this.weights.slice([y, x, hasLoad, 0], [1, 1, 1, this.actions]).reshape([this.actions]);
            const histPenalty = this.historyBuffer.mul(this.historyWeights).sum(0);
            const finalQ = spatialQ.add(histPenalty);
            
            // Повышен Epsilon для борьбы с застреванием
            if (Math.random() < 0.15) return Math.floor(Math.random() * this.actions);
            return finalQ.argMax().dataSync()[0];
        });
    }

    async learn(s, a, r, nextS) {
        tf.tidy(() => {
            const nextQ = this.weights.slice([nextS.y, nextS.x, nextS.hasLoad, 0], [1, 1, 1, this.actions]).max();
            const target = r + this.gamma * nextQ.dataSync()[0];
            const currentQ = this.weights.slice([s.y, s.x, s.hasLoad, a], [1, 1, 1, 1]).dataSync()[0];
            
            const error = target - currentQ;
            const updateTensor = tf.tensor1d([error * this.lr]);
            const indices = tf.tensor2d([[s.y, s.x, s.hasLoad, a]], [1, 4], 'int32');
            
            const deltaWeights = tf.scatterND(indices, updateTensor, this.weights.shape);
            this.weights.assign(this.weights.add(deltaWeights));

            const actionOH = tf.oneHot(a, this.actions).cast('float32').reshape([1, this.actions]);
            const oldHistory = this.historyBuffer.slice([1, 0], [this.hDepth - 1, this.actions]);
            this.historyBuffer.assign(tf.concat([oldHistory, actionOH], 0));
        });
    }
}

const SIZE = 10;
const CELL = 40;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let engine;
let robot = { x: 0, y: 0, dir: 1, hasLoad: 0 }; 
const obstacles = [[3,3], [3,4], [3,5], [6,6], [6,7], [6,8]];
let totalSteps = 0;

async function start() {
    await tf.setBackend('webgl');
    engine = new TensorEngine(SIZE);
    document.getElementById('status').innerText = "В пути...";
    gameStep();
}

function drawGame() {
    ctx.fillStyle = "#0d1117";
    ctx.fillRect(0, 0, 400, 400);
    ctx.strokeStyle = "#21262d";
    for(let i=0; i<=SIZE; i++) {
        ctx.beginPath(); ctx.moveTo(i*CELL, 0); ctx.lineTo(i*CELL, 400); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i*CELL); ctx.lineTo(400, i*CELL); ctx.stroke();
    }
    ctx.fillStyle = "#f85149";
    obstacles.forEach(([ox, oy]) => ctx.fillRect(ox*CELL+4, oy*CELL+4, CELL-8, CELL-8));
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = "#39d353"; ctx.fillRect(0, 0, CELL, CELL);
    ctx.fillStyle = "#e3b341"; ctx.fillRect(9*CELL, 9*CELL, CELL, CELL);
    ctx.globalAlpha = 1.0;
    ctx.save();
    ctx.translate(robot.x*CELL + CELL/2, robot.y*CELL + CELL/2);
    ctx.rotate(robot.dir * Math.PI/2);
    ctx.fillStyle = robot.hasLoad ? "#e3b341" : "#39d353";
    ctx.beginPath(); ctx.moveTo(0, -14); ctx.lineTo(12, 10); ctx.lineTo(-12, 10); ctx.fill();
    ctx.restore();
    renderHeatmaps();
}

async function renderHeatmaps() {
    for (let a = 0; a < 2; a++) {
        const data = await tf.tidy(() => {
            const t = engine.weights.slice([0, 0, robot.hasLoad, a], [SIZE, SIZE, 1, 1]).reshape([SIZE, SIZE]);
            const min = t.min(); const max = t.max();
            return t.sub(min).div(max.sub(min).add(0.0001)).dataSync();
        });
        const hCtx = document.getElementById(a === 0 ? 'mapForward' : 'mapTurn').getContext('2d');
        for (let y = 0; y < SIZE; y++) {
            for (let x = 0; x < SIZE; x++) {
                const intensity = Math.floor(data[y * SIZE + x] * 255);
                hCtx.fillStyle = `rgb(0, ${Math.floor(intensity/1.5)}, ${intensity})`;
                hCtx.fillRect(x * 10, y * 10, 10, 10);
            }
        }
    }
}

async function gameStep() {
    const s = { ...robot };
    const action = engine.predict(robot.y, robot.x, robot.hasLoad);
    let reward = -0.05; // Крошечный штраф за время

    if (action === 0) { // Вперед
        let nx = robot.x + (robot.dir === 1 ? 1 : robot.dir === 3 ? -1 : 0);
        let ny = robot.y + (robot.dir === 2 ? 1 : robot.dir === 0 ? -1 : 0);
        const isObs = obstacles.some(([ox, oy]) => ox === nx && oy === ny);
        const isWall = nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE;

        if (!isObs && !isWall) {
            robot.x = nx; robot.y = ny;
            reward = 1.5; // Большая награда за движение
        } else {
            reward = -3.0; // Умеренный штраф за препятствие
        }
    } else { // Поворот
        robot.dir = (robot.dir + 1) % 4;
        reward = -0.5; // Штраф за поворот
        
        // Маленький бонус за взгляд в сторону цели (Hints)
        if (!robot.hasLoad && (robot.dir === 1 || robot.dir === 2)) reward += 0.2;
        if (robot.hasLoad && (robot.dir === 0 || robot.dir === 3)) reward += 0.2;
    }

    if (robot.x === 9 && robot.y === 9 && !robot.hasLoad) {
        robot.hasLoad = 1; reward = 20;
    } else if (robot.x === 0 && robot.y === 0 && robot.hasLoad) {
        robot.hasLoad = 0; reward = 20;
    }

    await engine.learn(s, action, reward, { ...robot });
    document.getElementById('stepCountDisplay').innerText = ++totalSteps;
    document.getElementById('lastReward').innerText = reward.toFixed(1);
    document.getElementById('coords').innerText = `${robot.x}, ${robot.y}`;
    drawGame();
    setTimeout(gameStep, 40); 
}
start();
</script>
</body>
</html>

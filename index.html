<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Multi-Agent XAI Tensors 2026</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0b0d11; color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 10px; }
        .main-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        canvas { border: 2px solid #30363d; background: #000; border-radius: 4px; }
        .robot-panel { background: #161b22; padding: 15px; border-radius: 8px; width: 280px; border-top: 4px solid #444; }
        .robot1 { border-color: #00e676; } /* Зеленый */
        .robot2 { border-color: #2196f3; } /* Синий */
        .heatmap-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .h-box { text-align: center; font-size: 10px; color: #8b949e; }
        h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; }
        .stat-line { font-size: 13px; margin-bottom: 5px; }
    </style>
</head>
<body>

    <h2 style="color: #00e676; margin: 10px;">Multi-Agent Tensor XAI Engine</h2>
    
    <div class="main-container">
        <!-- Общая игровая арена -->
        <canvas id="gameCanvas" width="440" height="440"></canvas>

        <!-- Панель Робота 1 -->
        <div class="robot-panel robot1">
            <h3>Робот 1 (Зеленый)</h3>
            <div class="stat-line">Цель: <span id="r1-status">Загрузка</span></div>
            <div class="stat-line">Груз: <span id="r1-cargo">Нет</span></div>
            <div class="heatmap-grid">
                <div class="h-box"><canvas id="r1-mapF" width="100" height="100"></canvas><div>Q: Вперед</div></div>
                <div class="h-box"><canvas id="r1-mapT" width="100" height="100"></canvas><div>Q: Поворот</div></div>
            </div>
        </div>

        <!-- Панель Робота 2 -->
        <div class="robot-panel robot2">
            <h3>Робот 2 (Синий)</h3>
            <div class="stat-line">Цель: <span id="r2-status">Загрузка</span></div>
            <div class="stat-line">Груз: <span id="r2-cargo">Нет</span></div>
            <div class="heatmap-grid">
                <div class="h-box"><canvas id="r2-mapF" width="100" height="100"></canvas><div>Q: Вперед</div></div>
                <div class="h-box"><canvas id="r2-mapT" width="100" height="100"></canvas><div>Q: Поворот</div></div>
            </div>
        </div>
    </div>

<script>
/**
 * УНИВЕРСАЛЬНЫЙ ТЕНЗОРНЫЙ ДВИЖОК АГЕНТА
 */
class AgentEngine {
    constructor(size, color) {
        this.size = size;
        this.color = color;
        this.actions = 2; // 0: Прямо, 1: Поворот
        this.weights = tf.variable(tf.randomUniform([size, size, 2, this.actions], -0.01, 0.01));
        this.historyBuffer = tf.variable(tf.zeros([8, this.actions]));
        this.historyWeights = tf.variable(tf.fill([8, this.actions], -2.2));
        this.gamma = 0.96;
        this.lr = 0.3;
    }

    predict(y, x, hasLoad) {
        return tf.tidy(() => {
            const spatialQ = this.weights.slice([y, x, hasLoad, 0], [1, 1, 1, this.actions]).reshape([this.actions]);
            const histPenalty = this.historyBuffer.mul(this.historyWeights).sum(0);
            const finalQ = spatialQ.add(histPenalty);
            if (Math.random() < 0.1) return Math.floor(Math.random() * this.actions);
            return finalQ.argMax().dataSync()[0];
        });
    }

    async learn(s, a, r, nextS) {
        tf.tidy(() => {
            const nextQ = this.weights.slice([nextS.y, nextS.x, nextS.hasLoad, 0], [1, 1, 1, this.actions]).max();
            const target = r + this.gamma * nextQ.dataSync()[0];
            const currentQ = this.weights.slice([s.y, s.x, s.hasLoad, a], [1, 1, 1, 1]).dataSync()[0];
            
            const error = target - currentQ;
            const update = tf.tensor1d([error * this.lr]);
            const indices = tf.tensor2d([[s.y, s.x, s.hasLoad, a]], [1, 4], 'int32');
            
            this.weights.assign(this.weights.add(tf.scatterND(indices, update, this.weights.shape)));
            
            const actionOH = tf.oneHot(a, this.actions).cast('float32').reshape([1, this.actions]);
            const shifted = this.historyBuffer.slice([1, 0], [7, this.actions]);
            this.historyBuffer.assign(tf.concat([shifted, actionOH], 0));
        });
    }
}

/**
 * МИР И СИМУЛЯЦИЯ
 */
const SIZE = 11;
const CELL = 40;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Точки для Робота 1: [10,10] -> [0,0]
const R1_START = {x: 10, y: 10, target: {x: 0, y: 0}, color: '#00e676'};
// Точки для Робота 2: [0,10] -> [10,0]
const R2_START = {x: 0, y: 10, target: {x: 10, y: 0}, color: '#2196f3'};

const agents = [
    { id: 1, engine: new AgentEngine(SIZE, R1_START.color), pos: {x: 10, y: 10}, dir: 0, hasLoad: 0, config: R1_START },
    { id: 2, engine: new AgentEngine(SIZE, R2_START.color), pos: {x: 0, y: 10}, dir: 0, hasLoad: 0, config: R2_START }
];

const obstacles = [[5,2],[5,3],[5,4],[5,5],[5,6],[5,7],[5,8]];

async function main() {
    await tf.setBackend('webgl');
    loop();
}

function draw() {
    ctx.fillStyle = "#0d1117"; ctx.fillRect(0,0,440,440);
    ctx.strokeStyle = "#21262d";
    for(let i=0; i<=SIZE; i++){
        ctx.beginPath(); ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,440); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,i*CELL); ctx.lineTo(440,i*CELL); ctx.stroke();
    }
    // Препятствия
    ctx.fillStyle = "#f85149";
    obstacles.forEach(([x,y]) => ctx.fillRect(x*CELL+4, y*CELL+4, CELL-8, CELL-8));

    // Цели
    agents.forEach(a => {
        ctx.globalAlpha = 0.2; ctx.fillStyle = a.config.color;
        ctx.fillRect(a.config.x*CELL, a.config.y*CELL, CELL, CELL);
        ctx.fillRect(a.config.target.x*CELL, a.config.target.y*CELL, CELL, CELL);
        ctx.globalAlpha = 1.0;
        
        // Робот
        ctx.save();
        ctx.translate(a.pos.x*CELL+20, a.pos.y*CELL+20);
        ctx.rotate(a.dir * Math.PI/2);
        ctx.fillStyle = a.hasLoad ? "#ffeb3b" : a.config.color;
        ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10,8); ctx.lineTo(-10,8); ctx.fill();
        ctx.restore();
    });
    renderMaps();
}

async function renderMaps() {
    for(let agent of agents) {
        for(let a=0; a<2; a++) {
            const data = await tf.tidy(() => {
                const t = agent.engine.weights.slice([0,0,agent.hasLoad,a],[SIZE,SIZE,1,1]).reshape([SIZE,SIZE]);
                return t.sub(t.min()).div(t.max().sub(t.min()).add(0.0001)).dataSync();
            });
            const c = document.getElementById(`r${agent.id}-map${a===0?'F':'T'}`);
            const hCtx = c.getContext('2d');
            for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) {
                const v = Math.floor(data[y*SIZE+x]*255);
                hCtx.fillStyle = agent.id===1?`rgb(0,${v},${v/2})` : `rgb(0,${v/2},${v})`;
                hCtx.fillRect(x*9, y*9, 9, 9);
            }
        }
    }
}

async function loop() {
    for(let a of agents) {
        const s = { ...a.pos, hasLoad: a.hasLoad };
        const action = a.engine.predict(a.pos.y, a.pos.x, a.hasLoad);
        let r = -0.1;

        if(action === 0) { // Вперед
            let nx = a.pos.x + (a.dir===1?1 : a.dir===3?-1:0);
            let ny = a.pos.y + (a.dir===2?1 : a.dir===0?-1:0);
            const otherRobot = agents.find(other => other.id !== a.id).pos;
            const isColl = nx<0||nx>=SIZE||ny<0||ny>=SIZE||obstacles.some(([ox,oy])=>ox===nx&&oy===ny)||(nx===otherRobot.x&&ny===otherRobot.y);
            
            if(!isColl) { a.pos.x = nx; a.pos.y = ny; r = 1.2; }
            else { r = -6.0; }
        } else { a.dir = (a.dir+1)%4; r = -1.4; }

        // Проверка целей
        const target = a.hasLoad ? a.config : a.config.target;
        if(a.pos.x === target.x && a.pos.y === target.y) {
            a.hasLoad = 1 - a.hasLoad; r = 100;
            document.getElementById(`r${a.id}-cargo`).innerText = a.hasLoad ? "ДА" : "Нет";
            document.getElementById(`r${a.id}-status`).innerText = a.hasLoad ? "Возврат" : "Загрузка";
        }

        await a.engine.learn(s, action, r, { ...a.pos, hasLoad: a.hasLoad });
    }
    draw();
    setTimeout(loop, 40);
}

main();
</script>
</body>
</html>
